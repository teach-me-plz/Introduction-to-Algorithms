---
Date:
---
# Description
몇 가지 예시를 바탕으로 같은 동작을 수행하는 여러 알고리즘을 비교하고, 이를 통해서 알고리즘을 평가하는 방법을 알아보자.

# Standard - Time
일반적으로 알고리즘의 효율성을 평가하기 위해서는, 적절한 알고리즘이라면 그 결과는 동일하므로, 투입한 자원을 기준으로 생각하게 된다. 알고리즘의 실행에는 메모리, 단위 시간 당 소비 전력, 시간 등이 필요한데, 보통 메모리와 시간이 중요하게 고려되며, **특히 시간을 가장 중요하게 고려한다**.  
# Running Enviornment - RAM
모든 알고리즘은 그 실행 환경에 의해서 성능이 달라질 수 있다. 하드웨어도 예외는 아니기에 이를 위해서 RAM(Random Access Machine)이라는 가상의 실행 환경을 상정한다.

RAM은 모든 메모리에 대해서 Random Access, 즉 즉시 접근할 수 있으며, 모든 기초적인 Instruction(산술 연산, 등)이 동일한 단위 시간이 걸린다고 가정한다. 여기서 기초적인 명령어라고 한 것은 특정 동작을 하드웨어로 구현하면 그 성능이 대단히 좋아지기 때문인데, 이는 일반성에 위배되므로, 여기서는 생각하지 않는다.

또한, RAM은 단일 실행 흐름(Single Thread)를 가정한다. 일부 Multi-Thread를 고려한 알고리즘이 있으나, 이는 일부 특수한 경우를 의미하기에 고려하지 않는다.

RAM의 도입 목적은 순수하게 알고리즘의 성능을 비교하기 위해서 하드웨어의 영향을 배제함에 있다. 따라서 실제 알고리즘의 설계 및 구현에서는 실행 환경 또한 고려해야 한다.
# Input Size
입력의 크기는 가장 직관적으로 실행 시간에 영향을 미친다. 따라서 대부분의 경우 실행 시간을 입력 데이터의 크기에 대한 함수로 표현하게 된다.

# Asymptotic Analysis
앞서 설명한 요소들을 바탕으로 알고리즘을 평가한다. 여러 알고리즘에 일반적으로 적용하기 위해서, 적절하게 점근(Asymptotic) 평가 방법을 취하게 된다. 

## Big-O 
O 표기법은 알고리즘의 입력의 크기(n)에 따른 상승 속도의 상한선(upper bound)을 표현한다. 상한선이라 함은 이 알고리즘의 입력에 따른 증가 정도가 해당 표기법이 제시하는 정도를 넘지 않음을 의미한다. 다음의 예를 들어 생각해보자.
```
runtime : R(n) = 7n^3 + 4n^2 + 10;
Big-O : O(n^3), O(n^4), O(n^5), ...
```
위 알고리즘의 실행 시간의 함수를 R(n)이라 했을 때, R(n)의 가장 차수가 큰 항은 n^3이다. 구현이나 이런 환경의 영향에 따라 계수는 변할 수 있으므로, 알고리즘의 입력의 크기와 실행 시간의 특성을 의미하는 것은 가장 차수가 큰 항이다.

Big-O는 상승 정도의 상한선을 의미하므로, O(n^c)에 대해서 c가 3 이상이기만 하면 다 맞다.
## Omega
w 표기법은 알고리즘의 입력의 크기(n)에 따른 상승 속도의 하한선(lower bound)을 표현한다. 즉 이 알고리즘의 실행 시간의 함수, 그 가장 큰 차수가 이를 넘기만 하면 됨을 의미한다. 그 예시는 다음과 같다.
```
runtime : R(n) = 7n^3 + 4n^2 + 10;
omega : w(n^3), w(n^2), w(n^1), ...
```
R(n)의 가장 큰 차수는 3이고, R(n)의 입력의 크기에 따른 상승 속도(n^3)는 n^2 등과 같거나 빠르기에 w 표기법은 하한선을 의미한다.
## Theta
T 표기법은 알고리즘의 입력의 크기에 따른 상승 속도의 tight한 bound를 표현한다. 즉 알고리즘의 실행 시간의 함수에 가장 큰 차수를 가지는 항을 의미한다. 
```
runtime : R(n) = 7n^3 + 4n^2 + 10;
theta : t(n^3)
```
일반적으로 가장 자주 사용할 표기법이 바로 이것인데, 흔히 Big-O로 부르는 것은 사실 theta 표기법이다.

## Abuse
우리는 이러한 근사 표기법을 혼용하는 경향이 있다. 대부분 O 표기법으로 퉁치는 것이 바로 그 예시이다. 하지만, 앞서 말한 바와 같이, O 표기법은 상한선을 의미하므로, 정확한 표현은 아니다. 또한 알고리즘에 따라서는 input의 case에 따라서 그 성능이 달라지는 경우도 여럿 존재한다. 따라서 엄밀한 표현을 위해서는 반드시 고려해야 하는 부분이다.
## 극한을 통한 O 구하기
근사 표기법을 구하는 가장 쉬운 방법은 바로 극한을 활용하는 것이다. n을 무한대로 보냈을 때, 가장 지배적으로 작용하는 항이 곧 O이다. 

# 실전에서 알고리즘 평가하기
PS나 코테에서 Big-O를 적용하여 어떤 알고리즘을 써야 하는지, 혹은 어떤 알고리즘을 써서는 안되는지 판단해보자.

많은 글에서 1000_000_000회의 연산을 대략 1초가 걸린다고 한다. 다만, 이를 곧이 곧대로 믿는 것은 조금 곤란하다. BOJ를 기준으로 대략 다음과 같은 관계가 성립한다.

표, 1초 기준
1000_000 이상 -> O(N, N log N)
100_000 ~ 10_000 -> O(N log N)
1000 -> O(N^2)
100 -> O(N^3)
10~20 -> O(2^N)
10 -> N!

프로그래머스 및 LeetCode의 경우 BOJ보다 조금 넉넉한 것으로 확인된다. 

# References
- Introduction to Algorithms