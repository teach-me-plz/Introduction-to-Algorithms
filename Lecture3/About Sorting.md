---
Date: 2025-06-07
tags:
  - Algorithm
---
# 정렬이란 무엇인가
주어진 일련의 데이터를 일정한 기준으로 재배치 하는 것.

일반적으로 데이터는  배열에 담겨 있다고 생각한다.
# 정렬의 분류
정렬 알고리즘은 다양한 기준으로 분류할 수 있다.
## 추가 메모리 필요 여부
### In-place
정렬 과정에 추가적인 공간을 필요로 하지 않으며, 주어진 메모리 공간 내에서 데이터가 이동한다. in-place 정렬에는 다음의 특징이 있다.
1. 메모리 allocation 비용이 발생하지 않는다.
2. spatial locality가 증가한다.
## Out-place
정렬 과정에서 추가적인 공간을 필요로 하는 경우. 일반적으로 추가된 공간에 데이터를 정렬한 다음 원래 공간으로 데이터를 이동한다. Merge Sort를 비롯한 대부분의 merge계열 hybrid 정렬이 이에 해당한다.
1. panic safety : 추가된 공간에 데이터가 정렬된 형태로 복사되고, 이들이 다시 복원되는 구조이므로, 정렬 과정에서 panic이 발생했을 때, 원본 데이터의 손실을 막을 수 있음.
## 비교 여부
정렬을 수행하기 위해서는 그 대상이 되는 데이터 사이에 우열을 알 필요가 있다. 어떻게 우열을 가리는 지에 따라서 알고리즘을 분류할 수 있다. **일반적으로 두 데이터를 비교**하는 것을 통해서 우열을 확인하는데, 예외적으로 비교를 수행하지 않고, 객관적인 우열을 확인할 수 있는 경우에 대한 정렬 알고리즘이 존재한다.

비교를 수행하지 않고 정렬할 수 있다는 것은 비유하자면, 모종의 방법으로 **해당 데이터의의 객관적인 위치**를 알 수 있는 방법이 있음을 의미한다. 

다음은 비교를 수행하지 않는 알고리즘이다.
- Counting Sort
- Bucket Sort
- Radix Sort
# 왜 정렬을 하는가?
탐색에서 이득을 얻기 위함이다.  정렬을 통해서 우리는 이분 탐색을 수행할 수 있고, 이를 바탕으로 필요한 데이터를 보다 빠르게(n -> log n) 찾을 수 있다. 
# Key Value Mapping Technique
정렬 과정에서 가장 큰 지분을 차지하는 operation은 바로 read/write이다. 따라서, 정렬의 대상이 되는 데이터의 크기가 크면 클수록 그 정렬의 비용이 증가함을 의미한다.

이러한 경우 사용할 수 있는 테크닉이 바로 key-value mapping이다. 실제 데이터에 대응되는 적절한 key값을 구한 다음, 이들을 대신 정렬한다. 이후 정렬된 key의 배열을 읽으면서 그에 대응하는 value를 이동하면 정렬된 배열을 얻을 수 있다.
# 다양한 구현체
- [[Heap Sprt]]
- [[Quick Sort]]
- [[Merge Sort]]